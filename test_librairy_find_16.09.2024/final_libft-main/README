CE README ME SERT POUR MES TESTS ET MES COMMENTAIRES

					LIBFT

				STRLEN.C

PROTOTYPE:

size_t	ft_strlen(const char *s)



DESCRIPTION :

FONCTION QUI PERMET DE COMPTER LA LONGUEUR D'UNE STRING



MAIN :

 27 #include<stdio.h>
 28
 29 int     main()
 30 {
 31         char str[] = "0123456789";
 32         printf("%zu", ft_strlen(str));
 33 }



COMMENTAIRE :

NE PAS OUBLIER QUE SIZE_t EST L'EQUIVALENT D'UN INT on met %zu POUR LE PRINTF QUAND C EST UN SIZE_T

IL FAIT PARTI DE PLUSIEURS BIBLIOTHEQUES COMME STDDEF.H OU STDLIB.H

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


				STRRCHR.C


PROTOTYPE :

char	*ft_strrchr(const char *s, int c)



DESCRIPTION :

FONCTION QUI POINTE LA OU IL Y A LA DERNIERE OCCURENCE (DANS UNE CHAINED DE CARACTERE)



MAIN :

#include<stdio.h>

int	main()
{
	char	*str = "je suis un Chat gentil et en meme temps, je suis aussi un Chat espiegle";
	printf("%s", ft_strrchr(str, 'C'));
	printf("%s", ft_strrchr(str, 'T'));
	printf("%s", ft_strrchr(str, '\0'));
}



COMMENTAIRE :

JE NE SAIS PAS ENCORE POURQUOI MAIS SI ON FAIT printf("%s\n", ft_strrchr(str, 'T'))
(N'IMPORTE QUELLE CARACTERE QUI N'EST PAS DANS LA CHAINE DE CARACTERE) CA VA FAIRE UNE FAUTE DE SEGMENTATION (CORE DUMPED)

NE PAS OUBLIER QUE CONST EST QUELQUE CHOSE QUI NE CHANGE PAS EST QUE EN FONCTION DE L'EMPLACEMENT DU CONST (AVANT * OU APRES *) LAA VALEUR EST CONSTANT OU SINON
LE POINTEUR EST CONSTANT

ON PEUT CONVERTIR LA VARIABLE CONST CHAR * AVEC (char *) EXEMPLE : str = (char *)s;

CONST NE PERMET QUE LA LECTURE DE LA CHAINE DE CARACTERE


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


				STRCHR.C



PROTOTYPE :

char	*ft_strchr(const char *s, int c);



DESCRIPTION :

FONCTION QUI POINTE LA PREMIERE OCCURENCE (DANS UNE CHAINED DE CARACTERE)



MAIN :

#include<stdio.h>

int	main()
{
	char	*str = "je suis un Chat gentil et en meme temps, je suis aussi un Chat espiegle";
	printf("%s", ft_strchr(str, 'C'));
	printf("%s", ft_strchr(str, 'T'));
	printf("%s", ft_strchr(str, '\0'));
}



COMMENTAIRE :

JE NE SAIS PAS ENCORE POURQUOI MAIS SI ON FAIT printf("%s\n", ft_strrchr(str, 'T'))
(N'IMPORTE QUELLE CARACTERE QUI N'EST PAS DANS LA CHAINE DE CARACTERE) CA VA FAIRE UNE FAUTE DE SEGMENTATION (CORE DUMPED)

NE PAS OUBLIER QUE CONST EST QUELQUE CHOSE QUI NE CHANGE PAS EST QUE EN FONCTION DE L'EMPLACEMENT DU CONST (AVANT * OU APRES *) LAA VALEUR EST CONSTANT OU SINON
LE POINTEUR EST CONSTANT

ON PEUT CONVERTIR LA VARIABLE CONST CHAR * AVEC (char *) EXEMPLE : str = (char *)s;

CONST NE PERMET QUE LA LECTURE DE LA CHAINE DE CARACTERE


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



				FT_MEMSET.C



PROTOTYPE :

void	*ft_memset(void *s, int c, size_t n);



DESCRIPTION :

FONCTION QUI REMPLIE LES BYTES DE L'EMPLACEMENT MEMOIRE POINTÉ PAR S
LE NOMBRE DE FOIS QU'IL REMPLIE EST LIÉ A SIZE_T N
IL REMPLIE LES BYTES PAR LE CHARACTERE DEFINE PAR INT C



MAIN :

#include<stdio.h>

int    main()
{
    char    str[] = "134564456";

    printf("%p\n", ft_memset(str, 65, 8));
}



COMMENTAIRE :

ON INITIALISE UN CHAR CAR IL N'OCCUPENT QU'UN BYTE A LA FOIS COMPARE A INT QUI LUI PEUT PRENDRE 4 OU 8 BYTE;
SI ON UTILISE SIZEOF POUR SIZE_T N DANS LE MAIN

EXEMPLE

char s[10];
printf("%p", ft_memset(s, 'A', sizeof(s)));

N VAUT 10 (SIZEOF = ETENDUE)

%p POUR LES VOID * PRINT LES POINTEURS

CHAR *STR OU INT *TAB SONT JUSTE DES POINTEUR TANT QU'ONS À PAS ASSOCIÉ À UN TABLEAU OU UNE CHAINE DE CARACTÈRE

L'EMPLACEMENT DE LA MEMOIRE EST D'UN BYTE PAR ADRESSE;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			FT_MEMMOVE
DESCRIPTION :

MEMMOVE EST UTILE POUR EVITER LES CHEVAUCHEMENT DE MEMOIRE QUAND UNE ZONE SOURCE ET DE DESTINATION SE RECOUVRENT PARTIELLEMENT OU COMPLETEMENT

EXEMPLE :

buffer : [A, B, C, D, E, F, G, H, I, J]

source buffer[2] a buffer[6] = (C, D, E, F, G)
destination buffer[4] a buffer[8] = (E, F, G, H, I)

COMMENTAIRE :

le probleme est par exemple E, F, G
sont present a la fois dans la source et la destination ce qui constitue un chevauchement
car ils sont remplace par C D E J
mais E F G ont ete ecrase par C D E ce qui va creer un probleme
